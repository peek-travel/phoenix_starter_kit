#!/bin/bash

# Enable error handling
set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_status() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Function to get the current app name from mix.exs
get_app_name() {
    if [ -f "mix.exs" ]; then
        # Extract app name from mix.exs, handling both phoenix_starter_kit and renamed apps
        grep -E "app: :" mix.exs | sed 's/.*app: :\([^,]*\).*/\1/' | tr -d ' '
    else
        print_error "mix.exs not found. Are you in the project root?"
        exit 1
    fi
}

# Function to detect operating system
detect_os() {
    case "$(uname -s)" in
        Darwin*)    echo "macos" ;;
        Linux*)     echo "linux" ;;
        CYGWIN*|MINGW*|MSYS*) echo "windows" ;;
        *)          echo "unknown" ;;
    esac
}

# Function to install cloudflared
install_cloudflared() {
    local os
    os=$(detect_os)

    print_status "Installing cloudflared..."

    case $os in
        macos)
            if command -v brew &> /dev/null; then
                print_status "Using Homebrew to install cloudflared..."
                brew install cloudflared
            else
                print_error "Homebrew not found. Please install Homebrew first or install cloudflared manually:"
                echo "  https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/installation/"
                exit 1
            fi
            ;;
        linux)
            if command -v apt-get &> /dev/null; then
                print_status "Using apt to install cloudflared..."
                # Add Cloudflare's package repository
                curl -fsSL https://pkg.cloudflare.com/cloudflare-main.gpg | sudo tee /usr/share/keyrings/cloudflare-main.gpg >/dev/null
                echo "deb [signed-by=/usr/share/keyrings/cloudflare-main.gpg] https://pkg.cloudflare.com/cloudflared $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/cloudflared.list
                sudo apt-get update && sudo apt-get install cloudflared
            elif command -v yum &> /dev/null; then
                print_status "Using yum to install cloudflared..."
                sudo yum install -y yum-utils
                sudo yum-config-manager --add-repo https://pkg.cloudflare.com/cloudflared/rpm
                sudo yum install cloudflared
            elif command -v dnf &> /dev/null; then
                print_status "Using dnf to install cloudflared..."
                sudo dnf install -y dnf-plugins-core
                sudo dnf config-manager --add-repo https://pkg.cloudflare.com/cloudflared/rpm
                sudo dnf install cloudflared
            else
                print_error "No supported package manager found (apt, yum, or dnf). Please install cloudflared manually:"
                echo "  https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/installation/"
                exit 1
            fi
            ;;
        windows)
            print_error "Windows detected. Please install cloudflared manually:"
            echo "  Download from: https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/installation/"
            echo "  Or use: winget install --id Cloudflare.cloudflared"
            exit 1
            ;;
        *)
            print_error "Unknown operating system. Please install cloudflared manually:"
            echo "  https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/installation/"
            exit 1
            ;;
    esac

    # Verify installation
    if command -v cloudflared &> /dev/null; then
        print_success "cloudflared installed successfully!"
    else
        print_error "cloudflared installation failed. Please install manually."
        exit 1
    fi
}

# Function to check if cloudflared is installed and offer to install it
check_cloudflared() {
    if ! command -v cloudflared &> /dev/null; then
        print_warning "cloudflared is not installed."
        echo ""
        echo "cloudflared is required to create secure tunnels to your development server."
        echo "Would you like to install it automatically?"
        echo ""

        local os
        os=$(detect_os)
        case $os in
            macos)
                echo "This will run: brew install cloudflared"
                ;;
            linux)
                echo "This will install cloudflared using your system's package manager"
                ;;
            *)
                echo "Automatic installation not supported on this OS."
                echo "Please install manually: https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/installation/"
                exit 1
                ;;
        esac

        echo ""
        read -p "Install cloudflared? (y/n) " -n 1 -r
        echo

        if [[ $REPLY =~ ^[Yy]$ ]]; then
            install_cloudflared
        else
            print_status "Installation cancelled. Please install cloudflared manually and run this script again."
            echo "  macOS: brew install cloudflared"
            echo "  Linux: See https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/install-and-setup/installation/"
            exit 1
        fi
    else
        print_success "cloudflared is already installed"
    fi
}

# Function to check if user is authenticated
check_authentication() {
    if [ ! -f "$HOME/.cloudflared/cert.pem" ]; then
        print_warning "Cloudflare authentication required."
        print_status "Running: cloudflared tunnel login"
        cloudflared tunnel login
        print_success "Authentication complete!"
    else
        print_success "Already authenticated with Cloudflare"
    fi
}

# Function to delete DNS route for a tunnel
delete_dns_route() {
    local app_name=$1
    local hostname="${app_name}-dev.peeklabs.com"

    print_status "Cleaning up old DNS route for $hostname..."
    # Try to delete the DNS route - it's okay if it fails (might not exist)
    if cloudflared tunnel route dns delete "$hostname" 2>/dev/null; then
        print_success "Old DNS route deleted"
    else
        print_status "No existing DNS route to delete (this is normal)"
    fi
}

# Function to create tunnel (only if it doesn't exist or we don't have credentials)
create_tunnel() {
    local app_name=$1
    local tunnel_name="${app_name}-dev"

    # Check if tunnel already exists in Cloudflare
    if cloudflared tunnel list | grep -q "$tunnel_name"; then
        print_success "Tunnel '$tunnel_name' already exists in Cloudflare account"

        # Check if we have the credentials file locally
        local tunnel_uuid
        tunnel_uuid=$(cloudflared tunnel list | grep "$tunnel_name" | awk '{print $1}')
        local credentials_file="$HOME/.cloudflared/${tunnel_uuid}.json"

        if [ -f "$credentials_file" ]; then
            print_success "Credentials file found locally - reusing existing tunnel"
            return 0
        else
            print_warning "Tunnel exists but credentials file not found locally"
            print_status "This tunnel was likely created by another developer or on another machine."
            print_status "Deleting and recreating tunnel to get new credentials..."

            # Delete the DNS route first (it points to the old tunnel UUID)
            delete_dns_route "$app_name"

            # Now delete the tunnel
            cloudflared tunnel delete "$tunnel_name"
            print_success "Old tunnel deleted"
        fi
    fi

    print_status "Creating tunnel: $tunnel_name"
    cloudflared tunnel create "$tunnel_name"
    print_success "Tunnel '$tunnel_name' created successfully"
}

# Function to get tunnel UUID
get_tunnel_uuid() {
    local app_name=$1
    local tunnel_name="${app_name}-dev"

    cloudflared tunnel list | grep "$tunnel_name" | awk '{print $1}'
}

# Function to handle old config.yml file
handle_old_config() {
    local old_config="$HOME/.cloudflared/config.yml"

    if [ -f "$old_config" ]; then
        print_warning "Found old config.yml file from previous version"
        print_status "The new version uses app-specific config files to support multiple projects."
        echo ""
        echo "Would you like to rename the old config.yml to config.yml.backup?"
        echo "This will prevent conflicts and allow the new system to work properly."
        echo ""
        read -p "Rename old config.yml? (y/n) " -n 1 -r
        echo

        if [[ $REPLY =~ ^[Yy]$ ]]; then
            mv "$old_config" "${old_config}.backup.$(date +%s)"
            print_success "Old config.yml renamed to config.yml.backup"
        else
            print_warning "Keeping old config.yml - this may cause conflicts!"
            print_status "You can manually rename it later: mv ~/.cloudflared/config.yml ~/.cloudflared/config.yml.backup"
        fi
        echo ""
    fi
}

# Function to create or update config file
# Note: Each app gets its own config file (config-{app-name}-dev.yml) to support
# multiple projects running simultaneously without conflicts
setup_config() {
    local app_name=$1
    local tunnel_name="${app_name}-dev"
    local tunnel_uuid
    tunnel_uuid=$(get_tunnel_uuid "$app_name")
    local config_file="$HOME/.cloudflared/config-${app_name}-dev.yml"
    local hostname="${app_name}-dev.peeklabs.com"

    if [ -z "$tunnel_uuid" ]; then
        print_error "Could not find tunnel UUID for $tunnel_name"
        exit 1
    fi

    local credentials_file="$HOME/.cloudflared/${tunnel_uuid}.json"

    # Create the tunnel configuration
    local config_content="tunnel: $tunnel_name
credentials-file: $credentials_file

ingress:
  - hostname: $hostname
    service: http://localhost:4000
  - service: http_status:404"

    if [ -f "$config_file" ]; then
        # Check if config needs updating
        if grep -q "tunnel: $tunnel_name" "$config_file" && \
           grep -q "hostname: $hostname" "$config_file"; then
            print_success "Configuration for tunnel '$tunnel_name' already exists"
            return 0
        fi

        print_status "Updating existing configuration..."
    else
        print_status "Creating new configuration file: config-${app_name}-dev.yml"
    fi

    # Write the config
    echo "$config_content" > "$config_file"

    print_success "Configuration created/updated for tunnel '$tunnel_name'"
    print_status "Config file: ~/.cloudflared/config-${app_name}-dev.yml"
    print_status "Hostname: https://$hostname"
}

# Function to setup DNS routing
setup_dns() {
    local app_name=$1
    local tunnel_name="${app_name}-dev"
    local hostname="${app_name}-dev.peeklabs.com"

    print_status "Setting up DNS routing for $hostname"

    # Check if DNS record already exists by trying to route it
    # If it fails, it might already exist, so we'll just continue
    if cloudflared tunnel route dns "$tunnel_name" "$hostname" 2>/dev/null; then
        print_success "DNS routing created for $hostname"
        echo ""
        print_warning "IMPORTANT: For development, disable Cloudflare caching!"
        print_status "Go to Cloudflare Dashboard â†’ DNS Records"
        print_status "Find '$hostname' and click the orange cloud to make it gray (DNS Only)"
        print_status "This prevents caching issues during development."
        echo ""
    else
        print_warning "DNS routing might already exist for $hostname (this is normal)"
    fi
}

# Function to check if Phoenix server is running
check_phoenix_server() {
    if curl -s http://localhost:4000 > /dev/null 2>&1; then
        return 0  # Server is running
    else
        return 1  # Server is not running
    fi
}

# Function to check if tunnel is already running
check_tunnel_running() {
    local tunnel_name=$1

    # Check if there's already a cloudflared process running this tunnel
    if pgrep -f "cloudflared tunnel run $tunnel_name" > /dev/null; then
        return 0  # Tunnel is running
    else
        return 1  # Tunnel is not running
    fi
}

# Function to run the tunnel
run_tunnel() {
    local app_name=$1
    local tunnel_name="${app_name}-dev"
    local hostname="${app_name}-dev.peeklabs.com"

    # Check if tunnel is already running
    if check_tunnel_running "$tunnel_name"; then
        print_warning "Tunnel '$tunnel_name' appears to be already running!"
        print_status "If you want to restart it, please stop the existing process first."
        print_status "You can find the process with: ps aux | grep 'cloudflared tunnel run $tunnel_name'"
        exit 1
    fi

    # Check if Phoenix server is running and show prominent warning if not
    if ! check_phoenix_server; then
        echo ""
        echo "=================================================================="
        print_warning "IMPORTANT: Phoenix server is not running on localhost:4000!"
        echo "=================================================================="
        echo ""
        print_status "Your tunnel will start, but you need to start your Phoenix server"
        print_status "for the tunnel to work properly."
        echo ""
        print_status "To start your Phoenix server, run: bin/server"
        echo ""
        print_status "You can start the server in another terminal while keeping"
        print_status "this tunnel running."
        echo ""
        echo "=================================================================="
        echo ""
    fi

    print_success "Starting tunnel '$tunnel_name'..."
    print_success "Your app will be available at: https://$hostname"
    print_status "Press Ctrl+C to stop the tunnel"
    echo ""

    # Run the tunnel with the specific config file
    local config_file="$HOME/.cloudflared/config-${app_name}-dev.yml"
    cloudflared tunnel --config "$config_file" run "$tunnel_name"
}

# Function to show help
show_help() {
    echo "Phoenix Starter Kit - Cloudflare Tunnel Dev Setup"
    echo ""
    echo "Usage: $0 [options]"
    echo ""
    echo "Options:"
    echo "  -h, --help     Show this help message"
    echo "  --dry-run      Show what would be done without executing"
    echo ""
    echo "This script sets up a Cloudflare tunnel for development that:"
    echo "  1. Checks for old config files (and offers to migrate)"
    echo "  2. Authenticates with Cloudflare (if needed)"
    echo "  3. Creates a tunnel named '{app-name}-dev'"
    echo "  4. Configures tunnel to route {app-name}-dev.peeklabs.com to localhost:4000"
    echo "  5. Sets up DNS routing in Cloudflare"
    echo "  6. Starts the tunnel"
    echo ""
    echo "Prerequisites:"
    echo "  - cloudflared CLI (will offer to install automatically if missing)"
    echo "  - Access to peeklabs.com domain in Cloudflare"
    echo ""
    echo "Note: Phoenix server on localhost:4000 is recommended but not required to start the tunnel."
}

# Main execution
main() {
    # Handle command line arguments
    case "${1:-}" in
        -h|--help)
            show_help
            exit 0
            ;;
        --dry-run)
            DRY_RUN=true
            ;;
    esac

    print_status "Phoenix Starter Kit - Cloudflare Tunnel Dev Setup"
    echo ""

    # Get the current app name
    APP_NAME=$(get_app_name)
    print_status "Detected app name: $APP_NAME"

    if [ "${DRY_RUN:-}" = "true" ]; then
        print_status "DRY RUN MODE - showing what would be done:"
        echo "  - Tunnel name: ${APP_NAME}-dev"
        echo "  - Hostname: https://${APP_NAME}-dev.peeklabs.com"
        echo "  - Local service: http://localhost:4000"
        echo "  - Config file: ~/.cloudflared/config-${APP_NAME}-dev.yml"
        exit 0
    fi

    # Check prerequisites
    print_status "Checking prerequisites..."
    check_cloudflared

    # Step 1: Handle old config file if it exists
    print_status "Step 1: Checking for old configuration files..."
    handle_old_config

    # Step 2: Authenticate
    print_status "Step 2: Checking Cloudflare authentication..."
    check_authentication

    # Step 3: Create tunnel
    print_status "Step 3: Creating tunnel..."
    create_tunnel "$APP_NAME"

    # Step 4: Setup configuration
    print_status "Step 4: Setting up tunnel configuration..."
    setup_config "$APP_NAME"

    # Step 5: Setup DNS
    print_status "Step 5: Setting up DNS routing..."
    setup_dns "$APP_NAME"

    # Step 6: Run tunnel
    print_status "Step 6: Running tunnel..."
    run_tunnel "$APP_NAME"
}

# Run main function
main "$@"
